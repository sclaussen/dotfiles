#!/usr/bin/env bash

# Global archive timestamp - computed once per run
ARCHIVE_TIMESTAMP=""

# Get archive timestamp with letter suffix if needed
get_archive_timestamp() {
    if [ -n "$ARCHIVE_TIMESTAMP" ]; then
        echo "$ARCHIVE_TIMESTAMP"
        return
    fi

    local base_timestamp="$(date +"%Y-%m-%d")"
    local archive_timestamp="$base_timestamp"
    local archive_base_dir="$HOME/.archive"

    # Check if archive dir with this timestamp already exists, add letter suffix if needed
    if [ -d "$archive_base_dir" ]; then
        local matching_dirs=$(ls -d "$archive_base_dir/$base_timestamp"* 2>/dev/null | wc -l)
        if [ "$matching_dirs" -gt 0 ]; then
            # Find the next available suffix (a, b, c, ...)
            local ref_codes=(a b c d e f g h i j k l m n o p q r s t u v w x y z)
            for ref in "${ref_codes[@]}"; do
                local candidate="${base_timestamp}-${ref}"
                if [ ! -d "$archive_base_dir/$candidate" ]; then
                    archive_timestamp="$candidate"
                    break
                fi
            done
        fi
    fi

    ARCHIVE_TIMESTAMP="$archive_timestamp"
    echo "$ARCHIVE_TIMESTAMP"
}

copy_file() {
    local SOURCE="$1"
    local TARGET="$2"
    local ARCHIVE_MSG=""

    # Create parent directory if it doesn't exist
    mkdir -p "$(dirname "$TARGET")"

    # Archive existing file if it exists and is a regular file
    if [ -f "$TARGET" ]; then
        local timestamp=$(get_archive_timestamp)
        local archive_dir="$HOME/.archive/$timestamp"
        mkdir -p "$archive_dir"

        local archive_file="$archive_dir/$(basename $TARGET)"
        cp "$TARGET" "$archive_file"
        ARCHIVE_MSG=" (archived to ~/.archive/$timestamp/)"
    fi

    # Remove existing file/symlink if it exists
    if [ -e "$TARGET" ] || [ -L "$TARGET" ]; then
        rm -rf $TARGET
    fi

    echo "${TARGET/$HOME/~}: ${SOURCE/$HOME/~}$ARCHIVE_MSG"
    cp -r $SOURCE $TARGET
}

copy_dir_contents() {
    local SOURCE="$1"
    local TARGET="$2"

    # Create target directory if it doesn't exist
    mkdir -p "$TARGET"

    echo "${TARGET/$HOME/~}/*: ${SOURCE/$HOME/~}/*"
    cp -r $SOURCE/* $TARGET/
}

copy_emacs_d() {
    local SOURCE="$1"
    local TARGET="$2"
    local ARCHIVE_MSG=""
    local TEMP_ELPA="/tmp/emacs.d.elpa.$(date +%s).tmp"

    # If .emacs.d exists, preserve the elpa directory
    if [ -d "$TARGET" ]; then
        # Archive the entire .emacs.d first
        local timestamp=$(get_archive_timestamp)
        local archive_dir="$HOME/.archive/$timestamp"
        mkdir -p "$archive_dir"

        local archive_file="$archive_dir/emacs.d"
        cp -r "$TARGET" "$archive_file"
        ARCHIVE_MSG=" (archived to ~/.archive/$timestamp/)"

        # Save elpa directory if it exists
        if [ -d "$TARGET/elpa" ]; then
            mv "$TARGET/elpa" "$TEMP_ELPA"
        fi

        # Remove the old .emacs.d
        rm -rf "$TARGET"
    fi

    # Determine if elpa will be preserved
    local PRESERVED_MSG=""
    if [ -d "$TEMP_ELPA" ]; then
        PRESERVED_MSG=" (preserved ~/.emacs.d/elpa)"
    fi

    echo "${TARGET/$HOME/~}: ${SOURCE/$HOME/~}$ARCHIVE_MSG$PRESERVED_MSG"

    # Copy new .emacs.d
    cp -r "$SOURCE" "$TARGET"

    # Restore elpa directory if it was saved
    if [ -d "$TEMP_ELPA" ]; then
        rm -rf "$TARGET/elpa" 2>/dev/null  # Remove any elpa from source
        mv "$TEMP_ELPA" "$TARGET/elpa"
    fi
}

# Get the directory where this script is located
SRC="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Shell configuration
copy_file $SRC/sh/zshrc $HOME/.zshrc
copy_file $SRC/sh/zshrc.local $HOME/.zshrc.local

# Emacs configuration
copy_file $SRC/emacs/emacs $HOME/.emacs
copy_emacs_d $SRC/emacs/emacs.d $HOME/.emacs.d

# Claude commands and scripts
copy_file $SRC/templates/claude/commands/summarize.md $HOME/.claude/commands/summarize.md
mkdir -p $HOME/.claude/scripts
copy_file $SRC/templates/claude/scripts/summarize.sh $HOME/.claude/scripts/summarize.sh

